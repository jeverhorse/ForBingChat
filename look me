#include "arduino_secrets.h"
/*
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/cbff631f-e841-449c-8201-4752f3c053d9

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  CloudSwitch power;
  CloudTemperatureSensor temperature;
  bool wakeOnLan;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/
#define EXE_INTERVAL_1 300000
#define EXE_INTERVAL_2 900000

unsigned long lastExecutedMillis_1 = 0;  // vairable to save the last executed time for code block 1
unsigned long lastExecutedMillis_2 = 0;  // vairable to save the last executed time for code block 2
#define IR_RECEIVE_PIN 33                // D15
// #define IR_SEND_PIN 33                    // D4
#define DECODE_NEC
bool light = false;
bool computer = false;
bool plug = false;
String header;
#include "thingProperties.h"
#include <WiFiUdp.h>
#include <WakeOnLan.h>
#include <ESPmDNS.h>
#include <ArduinoOTA.h>
// #include "PinDefinitionsAndMore.h"
#include <IRremote.hpp>
WiFiUDP UDP;
WakeOnLan WOL(UDP);



const char *MACAddress = SECRET_MAC;
bool wakeOnLan_func = wakeOnLan;

WiFiServer server(80);

#ifdef __cplusplus

extern "C" {

#endif

  uint8_t temprature_sens_read();

#ifdef __cplusplus
}

#endif

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(115200);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
  */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  pinMode(2, OUTPUT);

  pinMode(13, OUTPUT);
  pinMode(14, OUTPUT);
  pinMode(27, OUTPUT);
  pinMode(15, OUTPUT);
  IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK);

  //OTA SETUP
  // ArduinoOTA
  //   .onStart([]() {
  //     String type;
  //     if (ArduinoOTA.getCommand() == U_FLASH)
  //       type = "sketch";
  //     else  // U_SPIFFS
  //       type = "filesystem";

  //     // NOTE: if updating SPIFFS this would be the place to unmount SPIFFS using SPIFFS.end()
  //     Serial.println("Start updating " + type);
  //   })
  //   .onEnd([]() {
  //     Serial.println("\nEnd");
  //   })
  //   .onProgress([](unsigned int progress, unsigned int total) {
  //     Serial.printf("Progress: %u%%\r", (progress / (total / 100)));
  //   })
  //   .onError([](ota_error_t error) {
  //     Serial.printf("Error[%u]: ", error);
  //     if (error == OTA_AUTH_ERROR) Serial.println("Auth Failed");
  //     else if (error == OTA_BEGIN_ERROR) Serial.println("Begin Failed");
  //     else if (error == OTA_CONNECT_ERROR) Serial.println("Connect Failed");
  //     else if (error == OTA_RECEIVE_ERROR) Serial.println("Receive Failed");
  //     else if (error == OTA_END_ERROR) Serial.println("End Failed");
  //   });

  // ArduinoOTA.begin();

  // Serial.println("Ready");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());

  //----
}

void loop() {
  ArduinoCloud.update();
  // ArduinoOTA.handle();
  // Your code here
  // if (wakeOnLan_func == false) {


  //   wakeOnLan = false;
  // }
  int result = (temprature_sens_read() - 32) / 1.8;
  // Serial.print("Temperature:");
  // Serial.print(result);
  // Serial.println(" C");
  temperature = result;

  if (IrReceiver.decode()) {

    /*
         * Print a short summary of received data
         */


    if (IrReceiver.decodedIRData.protocol != UNKNOWN) {
      IrReceiver.printIRResultShort(&Serial);
    }
    Serial.println();

    /*
         * !!!Important!!! Enable receiving of the next value,
         * since receiving has stopped after the end of the current received data packet.
         */
    IrReceiver.resume();  // Enable receiving of the next value

    /*
         * Finally, check the received data and perform actions according to the received command
         */
    if (IrReceiver.decodedIRData.command == 0x45) {

      digitalWrite(13, HIGH);
      power = true;
    } else if (IrReceiver.decodedIRData.command == 0x44) {
      digitalWrite(13, LOW);
      power = false;
    } else if (IrReceiver.decodedIRData.command == 0x46) {
      digitalWrite(14, HIGH);

    } else if (IrReceiver.decodedIRData.command == 0x40) {
      digitalWrite(14, LOW);

    } else if (IrReceiver.decodedIRData.command == 0x47) {
      digitalWrite(27, HIGH);

    } else if (IrReceiver.decodedIRData.command == 0x43) {
      digitalWrite(27, LOW);
    }
  }

  unsigned long currentMillis = millis();

  if (currentMillis - lastExecutedMillis_1 >= EXE_INTERVAL_1) {
    lastExecutedMillis_1 = currentMillis;  // save the last executed time

    digitalWrite(15, HIGH);
  }

  if (currentMillis - lastExecutedMillis_2 >= EXE_INTERVAL_2) {
    lastExecutedMillis_2 = currentMillis;  // save the last executed time

    digitalWrite(15, LOW);
  }
  //web server

  WiFiClient client = server.available();

  if (client) {
    // Client connected
    Serial.println("New client.");
    // Get the current line of the request
    header = client.readStringUntil('\r');
    // Print the request
    Serial.println(header);
    // Check if the request is a POST
    if (header.indexOf("POST") >= 0) {
      // Check the command



      // light---->
      //tagle
      if (header.indexOf("/Tlight") >= 0) {

        if (light == false) {
          light = true;
          Serial.println("on");
          digitalWrite(13, HIGH);
        } else {
          light = false;
          Serial.println("off");
          digitalWrite(13, LOW);
        }
      }
      //on
      else if (header.indexOf("/lighton") >= 0) {

        light = true;
        Serial.println("on");
        digitalWrite(13, HIGH);

        //off
      } else if (header.indexOf("/lightoff") >= 0) {

        light = false;
        Serial.println("off");
        digitalWrite(13, LOW);
      }

      // computer--->
      if (header.indexOf("/Tcomputer") >= 0) {

        if (computer == false) {
          computer = true;
          Serial.println("on");
          digitalWrite(27, HIGH);
        } else {
          computer = false;
          Serial.println("off");
          digitalWrite(27, LOW);
        }
      }
      //on
      else if (header.indexOf("/computeron") >= 0) {

        computer = true;
        Serial.println("on");
        digitalWrite(27, HIGH);

        //off
      } else if (header.indexOf("/computeroff") >= 0) {

        computer = false;
        Serial.println("off");
        digitalWrite(27, LOW);
      }
      // plug--->
      if (header.indexOf("/Tplug") >= 0) {

        if (plug == false) {
          plug = true;
          Serial.println("on");
          digitalWrite(14, HIGH);
        } else {
          plug = false;
          Serial.println("off");
          digitalWrite(14, LOW);
        }
      }
      //on
      else if (header.indexOf("/plugon") >= 0) {

        plug = true;
        Serial.println("on");
        digitalWrite(14, HIGH);

        //off
      } else if (header.indexOf("/plugoff") >= 0) {

        plug = false;
        Serial.println("off");
        digitalWrite(14, LOW);
      }
      //
    }
    // Clear the header variable
  }
}


/*
  Since WakeOnLan is READ_WRITE variable, onWakeOnLanChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onWakeOnLanChange() {

  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
  // Add your code here to act upon WakeOnLan change
  if (wakeOnLan == true) {

    Serial.println("Sent WOL packet");
    WOL.sendMagicPacket(MACAddress);

    digitalWrite(2, HIGH);
    delay(400);
    digitalWrite(2, LOW);
    delay(400);
    digitalWrite(2, HIGH);
    wakeOnLan = false;
  } else {
    Serial.println("Button not clicked");
    digitalWrite(2, LOW);
  }
}




/*
  Since Temperature is READ_WRITE variable, onTemperatureChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onTemperatureChange() {
  // Add your code here to act upon Temperature change
  Serial.println("temp");
}

/*
  Since Power is READ_WRITE variable, onPowerChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onPowerChange() {
  // Add your code here to act upon Power change

  if (power == true) {

    digitalWrite(27, HIGH);

  } else {
    Serial.println("power off");
    digitalWrite(27, LOW);
  }
}
